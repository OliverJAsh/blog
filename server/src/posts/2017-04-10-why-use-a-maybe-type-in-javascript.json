{
    "title": "Why use a Maybe type in JavaScript?",
    "date": "2017-04-10",
    "description": "The Maybe type is a popular abstraction for defining values that may or may not exist. Why should you use it in JavaScript?",
    "body": "<p>The <code>Maybe</code> type is a popular abstraction for defining values that may or may not exist. Many languages use it in place of nullable values. For example, it can be found in Haskell, Elm, Scala (<code>Option</code>), and Swift (<code>Optional</code>). In this blog post, I try to explain the advantages of using a similar abstraction specifically as it applies to JavaScript.</p><p>Most of my work over the past 4 years has been based around JavaScript programs. I’ve lost count of the number of times I’ve seen bugs because of:</p><ul><li>unexpected <code>undefined</code>/<code>null</code></li><li>boolean coercion</li></ul><p>Many bugs appear because of human error, and these types of bugs fit into that category. I want to protect myself, and others, from repeating these mistakes. We’re only human after all.</p><p>In JavaScript, <code>Maybe</code> can be seen as an alternative to these bad parts of JavaScript—namely nullable values and boolean coercion. In practice, <code>Maybe</code> enforces constraints which mean we can eradicate these types of bugs from our programs.</p><p>Before looking at <code>Maybe</code>, let’s have a look at what these bugs look like in a world without <code>Maybe</code>.</p><p>Note: these examples use the <code>Maybe</code> type as it is defined in Folktale’s <a href=\"http://docs.folktalejs.org/en/latest/api/data/maybe/Maybe.html\">data.maybe</a>.</p><h3 id=\"No_more_unexpected_undefinednull_bugs\">No more unexpected <code>undefined</code>/<code>null</code> bugs</h3><p>JavaScript has nullable values (<code>undefined</code> and <code>null</code>) to express empty cases. For example:</p><pre><code class=\"language-js\">// Type is Array<{ id: number, name: string }>\nconst users = [\n    { id: 1, name: 'Bob' },\n    { id: 2, name: 'Saffron' }\n]\n// Type is { id: number, name: string } | undefined\n// This will evaluate to undefined\nconst loggedInUser = users.find(user => user.id === 5);\n// => undefined\n</code></pre><p><code>loggedInUser</code> could be <code>undefined</code>—given any set of <code>users</code> with this type, we can’t be certain what <code>loggedInUser</code> will evaluate to until runtime.</p><p>Nonetheless, JavaScript allows us to go ahead and use our <code>loggedInUser</code> variable as if it’s always safe to do so.</p><p><em>Assuming <code>loggedInUser</code> will never be <code>undefined</code></em>, this code is fine, until all of a sudden this assumption breaks down.</p><pre><code class=\"language-js\">// If loggedInUser is undefined, this will throw an\n// exception\n`Hello, ${loggedInUser.name}`;\n// => Uncaught TypeError: Cannot read property 'name'\n// of undefined\n</code></pre><p><strong>This is a bug that can easily be written into a program, and unless we somehow remember to handle this edge case, we won’t discover the bug until it eventually manifests itself in some production code.</strong></p><p>ProTip: In TypeScript with the <code>strictNullChecks</code> option enabled, the compiler will force you to handle the <code>undefined</code> case in this example:</p><pre><code class=\"language-js\">`Hello, ${loggedInUser.name}`;\n//        ^^^^^^^^^^^^\n//        Object is possibly 'undefined'\n</code></pre><p>JavaScript allows you to use nullable values in strings. This is nearly always a programming mistake, but you won’t even get a runtime error:</p><pre><code class=\"language-js\">const users = { 1: 'Bob', 2: 'Saffron' }; // Record<string, string>\n// Type is { id: number, name: string } | undefined,\n// will evaluate to undefined\nconst loggedInUserName = users[5];\nconst message = `Hello, ${loggedInUserName}`;\n// => \"Hello, undefined\"\n</code></pre><p>(This one would not be caught by TypeScript’s <code>strictNullChecks</code> option—see <a href=\"https://github.com/Microsoft/TypeScript/issues/7989\">issue #7989 for details</a>.)</p><p>Likewise, JavaScript allows us to use a nullable value in calculations, in which case you will likely see unexpected <code>NaN</code>s.</p><p>If we used a <code>Maybe</code> type, it wouldn’t be possible to write these bugs. This is because you’re forced to:</p><ul><li><code>map</code> over the <code>Maybe</code> to use the inner value</li><li>provide a default when finally reading the inner value with <code>getOrElse</code>.</li></ul><p>Let’s look at an example:</p><pre><code class=\"language-js\">const users = [\n    { id: 1, name: 'Bob' },\n    { id: 2, name: 'Saffron' }\n];\n// Array<{ id: number, name: string }>\n// Type is Maybe<{ id: number, name: string }>\nconst maybeLoggedInUser1 = Maybe.fromNullable(\n    users.find(user => user.id === 5)\n);\n// => Nothing\nconst message1 = maybeLoggedInUser1\n    .map(loggedInUser => `Hello, ${loggedInUser.name}`)\n    .getOrElse('');\n// => ''\n// Type is Maybe<{ id: number, name: string }>\nconst maybeLoggedInUser2 = Maybe.fromNullable(\n    users.find(user => user.id === 2)\n);\n// => Just<{ id: 2, name: 'Saffron' }>\nconst message2 = maybeLoggedInUser2\n    .map(loggedInUser => `Hello, ${loggedInUser.name}`)\n    .getOrElse('');\n// => 'Hello, Saffron'\n</code></pre><p>Using this abstraction, this whole class of bugs (unexpected <code>undefined</code>/<code>null</code>s) can be eradicated from our programs.</p><h3 id=\"No_more_boolean_coercion_bugs\">No more boolean coercion bugs</h3><p>In JavaScript, we can use a value of any type in conditionals. JavaScript dynamically converts our value into a boolean on-the-go, a process known as coercion:</p><pre><code class=\"language-js\">const array1 = [1,2,3];\nif (array1.length) {\n    // Code here will be ran\n}\n!!array1.length;\n// => true\nconst array2 = [];\nif (array2.length) {\n    // Code here will not be ran\n}\n!!array2.length;\n// => false\n</code></pre><p>When referring to a value that will undergo boolean coercion, we call it <a href=\"https://developer.mozilla.org/en/docs/Glossary/Truthy\">truthy or falsy</a>. In this example, <code>array.length</code> is a truthy value, unless the array is empty, in which case it is falsy.</p><pre><code class=\"language-js\">const users = { Bob: 0, Saffron: 10 };\nconst getAge = name => {\n    // Type is number | undefined\n    const maybeAge = users[name];\n    // maybeAge is implicitly coerced into a boolean\n    const message = maybeAge\n        ? `${name} is ${maybeAge}`\n        : 'No age';\n    return message;\n};\ngetAge('Saffron') // => Saffron is 10\ngetAge('Luke') // => No age\n</code></pre><p><em>Assuming <code>maybeAge</code> will never be <code>0</code></em>, this code is fine, until (again) all of a sudden this assumption breaks down. If <code>maybeAge</code> is <code>0</code>, it will be coerced into a boolean as <code>false</code>, so our function wrongly interprets this as “age does not exist”:</p><pre><code class=\"language-js\">getAge('Bob') // => No age (!)</span>\n</code></pre><p><strong>This is a bug that can easily be written into a program, and unless we somehow remember to handle this edge case, we won’t discover the bug until it eventually manifests itself in some production code.</strong></p><p>To fix this, we must make our condition explicit, instead of relying on JavaScript’s boolean coercion:</p><pre><code class=\"language-js\">const users = { Bob: 0, Saffron: 10 };\nconst getAge = name => {\n    // Type is number | undefined\n    const maybeAge = users[name];\n    // Type is string\n    const message = maybeAge !== undefined\n        ? `${name} is ${maybeAge}`\n        : 'No age';\n    return message;\n};\ngetAge('Saffron') // => Saffron is 10\ngetAge('Luke') // => No age\ngetAge('Bob') // => Bob is 0\n</code></pre><p>This is correct, and in this example this would probably suffice. However, when we need to chain calculations, we sacrifice expressiveness for correctness:</p><pre><code class=\"language-js\">const getNextAge = name => {\n    // Type is number | undefined\n    const maybeAge = users[name];\n    // Type is number | undefined\n    const maybeNextAge = maybeAge !== undefined\n        ? maybeAge + 1\n        : undefined;\n    // Type is string\n    const message = maybeNextAge !== undefined\n        ? `${name}’s next age is ${maybeNextAge}`\n        : 'No age';\n    return message;\n};\n</code></pre><p>Relying on JavaScript’s implicit boolean coercion, as we saw above, can be perfectly safe in some use cases, depending on the type and expected behaviour. For that reason it is possible to selectively rely on boolean coercion when we know it is safe to do so. However, this approach requires a lot of discipline and is prone to human error.</p><p>If we want to avoid boolean coercion bugs in our code without having to require discipline or extra verbosity, we can use a <code>Maybe</code> type.</p><p>We can think of <code>Maybe</code> as an abstraction over the condition checking “does this value exist” (<code>maybeX !==undefined</code>), with an API for performing common operations to the inner value:</p><pre><code class=\"language-js\">// map\nconst maybeNextAge = maybeAge !== undefined\n    ? maybeAge + 1\n    : undefined;\nconst message = maybeNextAge !== undefined\n    // map\n    ? `${name}’s next age is ${maybeNextAge}`\n    // getOrElse\n    : 'No age';\n</code></pre><p>Finally, here is how our example code looks using <code>Maybe</code>:</p><pre><code class=\"language-js\">const getNextAge = name => {\n    // Type is number | undefined\n    const maybeAge = Maybe.fromNullable(users[name]);\n    // Type is string\n    const message = maybeAge\n        .map(age => age + 1)\n        .map(nextAge => `${name}’s next age is ${nextAge}`)\n        .getOrElse('No age');\n    return message;\n};\n</code></pre><p>With <code>Maybe</code>, we never have to write a condition to check if a value exists or not. Our code is more concise, and most importantly, we can no longer write boolean coercion errors into our program.</p><p>ProTip: If you’re a TypeScript user, <a href=\"https://palantir.github.io/tslint/\">tslint</a> has a rule to disallow boolean coercion called <a href=\"https://palantir.github.io/tslint/rules/strict-boolean-expressions/\"><code>strict-boolean-expressions</code></a>.</p><h3 id=\"Caveats\">Caveats</h3><p>Where JavaScript may return “nothing”, it will return <code>undefined</code> or <code>null</code>. In practice, this means you end up defining helper functions to handle the conversion to a <code>Maybe</code>. Of course, you then must remember to use these helper functions. (In languages with native <code>Maybe</code> types, this is usually the standard for most APIs.)</p><h3 id=\"Maybe_implementations\"><code>Maybe</code> implementations</h3><p>Choose your weapon from any of these libraries which provide decent implementations of the <code>Maybe</code> type (also called <code>Option</code>). The differences are mostly insignificant. I would personally pick something that conforms to the <a href=\"https://github.com/fantasyland/fantasy-land\">Fantasy Land spec</a>, as this will provide interoperability with other conforming <code>Maybe</code> implementations, and also with libraries which rely on the interfaces defined in this spec, such as <a href=\"https://github.com/sanctuary-js/sanctuary\">Sanctuary</a> and <a href=\"https://github.com/ramda/ramda\">Ramda</a>.</p><ul><li><a href=\"https://github.com/gcanti/fp-ts\">https://github.com/gcanti/fp-ts (my favourite)</a></li><li><a href=\"https://github.com/folktale/data.maybe\">https://github.com/folktale/data.maybe</a></li><li><a href=\"https://sanctuary.js.org/#maybe-type\">https://sanctuary.js.org/#maybe-type</a></li><li><a href=\"https://github.com/jiaweihli/monapt#monaptoption\">https://github.com/jiaweihli/monapt#monaptoption</a></li><li><a href=\"https://github.com/alexanderjarvis/maybe\">https://github.com/alexanderjarvis/maybe</a></li><li><a href=\"https://github.com/fantasyland/fantasy-maybes\">https://github.com/fantasyland/fantasy-maybes</a></li></ul><h3 id=\"Conclusion\">Conclusion</h3><p><code>Maybe</code> enforces constraints which make it impossible to write certain types of common bugs into our programs.</p><p>In JavaScript, there are many places we must handle nullable values, such as when accessing a value from an array with bracket notation or <code>Array.prototype.find</code>. However, it’s easy to forget to handle these null cases. By switching to APIs that return <code>Maybe</code> instead of nullable values, we are forced to handle all cases—when the value does and does not exist.</p><p>JavaScript’s boolean coercion is often thought as convenient, but it’s easy to forget about the nuances of this process. As we have seen, boolean coercion does much more than just check for existance, so in practice it is not safe to use non-boolean values as conditions. <code>Maybe</code> perfectly captures the idea of a value that may or may not exist, and by adopting this abstraction, we can no longer repeat this mistake.</p><p>There are most definitely more advantages and disadvantages to using a <code>Maybe</code> type in your JavaScript that I haven’t touched upon here. If you have any comments or thoughts, I would love to hear them. Get in touch on <a href=\"https://twitter.com/OliverJAsh\">Twitter</a>. :-)</p><p><em>Huge thanks to those who reviewed this article: <a href=\"https://twitter.com/theefer\">Sébastien Cevey</a>, <a href=\"https://twitter.com/davidrapson\">David Rapson</a>, and <a href=\"https://twitter.com/am_i_tom\">Tom Harding</a>.</em></p>"
}
